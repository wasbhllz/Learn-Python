# 概述
## C语言优点
- 效率高
- 控制能力强
- 程序可移植
- 通用性强,使用广泛

## 编译器
是把代码转换成计算机内部指令的程序

## 编程过程
编译器将源代码编译为目标代码,通过链接器将库代码和启动代码链接起来,从而成为机器可以直接读取的二进制代码(指令集)

**注意**:本书包含一些强调特定知识点的特殊元素，提示、注意、警告，将以如下形式出现在本书中：边栏边栏提供更深入的讨论或额外的背景，有助于解释当前的主题。提示提示一般都短小精悍，帮助读者理解一些特殊的编程情况。警告用于警告读者注意一些潜在的陷阱。注意提供一些评论，提醒读者不要误入歧途。
![image.png](https://s1.vika.cn/space/2023/12/24/4a2bdf3a971449f98b8a90142dd1cc7b)
![image-1.png](https://s1.vika.cn/space/2023/12/24/17197ee486e54e7eba5e09b5eaead97d)
**
## 程序结构
**程序结构一般函数头和函数体组成**，一个简单的 C 程序的格式如下：
```C
#include <stdio.h> //头文件：预处理文件
int main() //主函数
{
     语句
     return 0;
}
```
（函数体内语句都以分号结尾。）
**I/O 的原意是标准输入输出，现指交互式**
## 与python不同
- C 是编译型语言, python 是解释型语言
- 固定的输入输出设置
- 声明变量
- 函数体内需要打分号;
# 基础知识
## 自定义函数
声明(确定返回值,参数) → 调用(执行函数功能) → 定义(编写函数定义)
`void a(void)`中前面的`void`表示没有返回值，后面`void`表示没有参数,可以省略不写

变量分为**全局变量**和**局部变量**

## 常量
- 字面常量
- `const` 修饰的常变量
- `#define` 定义的符号变量(一般用大写表示)
**const和#define之间的区别在于，前者使用内存进行存储，而后者不使用，直接在预处理器替换完成。**

## 数据类型
### 基本数据类型
字符类型和占内存的字节大小有关
#### 整型
整数可以表示为十进制、八进制或十六进制
- 0 前缀表示八进制数
- x 或 X 前级表示十六进制数

l或L前缀表明该值是 long 类型
ll或LL前缀表明该值是 longlong 类型

单引号用来表示**字符常量**，双引号用来表示**字符串常量**。

##### 字符串
**null 字符: `\0`是字符串的结束标志**
- 花括号中数组的长度超过方括号中的数值时, 会报错
- 方括号中的数值超过花括号中数组的长度的时, 会**自动生成 0 填补空位**
- 计算字符数组的长度,由于字符没有`\0`,会计算之后储存空间的长度,直到`\0`
例题:
```C
#include <stdio.h>
int main()
char arr[] = {'b','i','t'};
printf("%d\n"，strlen(arr));
return 0;
```
题目内容:
A.3
B.4
c.随机值
D.5

数组不完全初始化带来的默认初始化

#### 浮点类型
##### Float(单精度浮点数)
8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。
对于指数部分-128～128
对于尾数部分2的23次方等价于十进制8388608，7位有效数字

##### Double(双精度浮点数)
11位用于表示指数的值和符号，剩下52位用于表示尾数部分及其符号。

打印`long double`类型要使用`%Lf`、`%Le`或`%La`转换说明 

```ad-tldr
title:VS中的小数默认是double类型，需要在小数后面加上`f`表示float类型，如：3.14f
```

## 转义序列
- 字面常量
- `\ddd` 表示一个八进制数,数字从0~7，满八进一
- `\xdd` 表示一个十六进制数

## 操作符
### 1.算术操作符
- 整数运算：运算符的两方都是整数
- 浮点运算：运算符的一方至少有一个浮点数
- `%`取模运算是取余数,结果是整数

**'%'操作符不能使用浮点数**
![image-2.png](https://s1.vika.cn/space/2024/01/13/080cac20845941a09e5f451f1c0393af)

### 2.移位操作符
```ad-tldr
title:**移位和按位中的'位'是指二进制位**
```
**左移**（<<）将一个运算对象的二进制数值（补码）向左移动指定位数（正整数），通过丢弃高位字节并用低位字节（0）填充，从而为运算对象创造一个左移位
正数的原码、反码、补码都相同，而负数的原码、反码、补码需要计算得出
相当于乘以\(2^n\)
```
十进制数：
-7
原码：
10000000000000000000000000000111
反码：取反除最高位外的原码
11111111111111111111111111111000
补码：在反码的基础上加1
11111111111111111111111111111001
```

**右移**（>>）将一个运算对象的二进制数值（补码）向右移动指定位数，通过丢弃高位字节并用低位字节（0）填充，分为算术右移和逻辑右移
算术右移：和符号相同的填充
逻辑右移：高位填0
相当于除以\(2^n\)
```ad-tldr
title:一般机器和解释器一般进行的是算术右移
```

### 3.位操作符
在C语言中，按位操作符用于对整数类型的数据的二进制位进行操作。这些操作符包括：
- **按位与** (`&`): 对两个数的每一位进行逻辑与操作。如果两个相应的位都是1，则结果位为1，否则为0。常用于清零和取指定位的值
- **按位或** (`|`): 对两个数的每一位进行逻辑或操作。如果两个相应的位中至少有一个为1，则结果位为1，否则为0。常用于设置位的值
- **按位异或** (`^`): 对两个数的每一位进行逻辑异或操作。如果两个相应的位相异，则结果位为1，否则为0。常用于翻转指定位的值
- **按位取反** (`~`): 对一个数的二进制补码按位取反,将1变为0，将0变为1。常用于生成一个数的补码

这些操作符在位掩码、状态管理、权限控制、数据加密等领域有广泛的应用

### 4.单目操作符
- `sizeof(变量)`返回操作数的类型长度(以字节为单位)
- `&` 取地址符
- `*`间接访问操作符(解引用操作符)，对指针中的值进行操作
- `++` 自增操作符，前置、后置++
- `--` 自减操作符，前置、后置--
- `(类型)`强制类型转换

```
++i 前置，先增加，后使用
i++ 后置，先使用（复制、打印或返回），后增加
```

### 5.关系操作符
`>`
`>=`
`<`
`<=`
`!=`
`==`
- 关系操作符的结果是布尔值
- 关系操作符的优先级低于算术操作符
- 关系操作符的优先级高于赋值操作符

### 6.逻辑操作符
- `&&` 逻辑与：左边为假，右边就不计算了
- `||` 逻辑或：左边为真，右边就不计算了
- `!` 逻辑非

### 7.条件操作符
**三目操作符**
```
表达式1 ? 表达式2: 表达式3
```
表达式1为真，返回表达式2的值，否则返回表达式3的值

### 8.逗号表达式
```
表达式1,表达式2,表达式3,...
```
以最后的表达式为结果

### 下标引用、函数调用和结构体访问操作符
- `[索引数]` 下标引用，跟数组的指针一起用
- `()` 函数调用
**`.` 结构成员引用**

可以使用点操作符来访问其成员，例如，如果`student`是一个`Student`结构体的实例，你可以使用`student.name`来访问其`name`成员
**`->` 结构成员访问**

例如，如果`pStudent`是指向`Student`结构体的指针，你可以使用`pStudent->name`来访问其`name`成员。

### 7.运算符优先级
运算符的优先级和结合性
#### 整形提升
- 当**小于int类型**的类型进行计算时，如果是有符号类型，会将补码按最高位的符号位进行填充，否则按0填充
- **高于int类型**的会按计算中最高类型向上取整
#### 表达式的运算
虽然运算符的顺序是已经规范定义的，但在实际编程中，我们还是需要注意以下情况：
当进行**相同变量的多次运算**时，确实可能存在未定义行为，特别是在并行计算或优化编译的情况下

### Bool 类型
用于表示布尔值，即逻辑值`true`和`false`。因为C语言用值1表示`true`，值0表示`false`，所以`Bool`类型实际上也是一种整数类型

## 关键字
### typedef类型重命名 
用途：类型定义太长太复杂的时候进行重命名 

### int有符号和unsigned int无符号
修饰整型关键字

1. **有符号和无符号**：有符号整数表示正、负数和零，无符号整数只表示非负数。
2. **表示方式**：有符号整数用最高位区分正负，无符号整数所有位表示数值。
3. **有符号整数应用**：处理可能为负的数据，如温度、差值、偏移量。
4. **无符号整数应用**：处理非负数据，如计数、索引、位操作。

### static
**静态局部变量**:修饰局部变量出了作用域是不销毁的
栈区：局部变量—>静态变量（静态区）
**静态全局变量**:修饰全局变量的外部链接属性变成了内部属性(作用域变小了,原本的范围是整个项目)
**静态函数**：效果和静态全局变量类似
- 限制变量和函数的作用域，使其只能在本文件或本函数内访问，隐藏其它文件或函数的同名变量和函数。
- 保持变量的内容的持久，使其在程序运行期间一直存在，不受函数调用的影响。
- 默认初始化变量为0，省去了手动赋值的操作。

### register：寄存器变量
- 只能作用于局部变量，不能作用于全局变量。
- 只是向编译器提出请求，但不一定请求成功。编译器会根据寄存器的数量和类型来决定是否将变量放入寄存器中。
- register变量必须是能被CPU寄存器所接受的类型，通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。有些机器的寄存器也能存放浮点数。
- 不能用&运算符获取register变量的地址，因为寄存器变量可能不存放在内存中，而寄存器不能通过地址直接访问。
- 不能与static关键字一起使用，因为static关键字表示变量的存储周期是整个程序的运行时间，而register关键字表示变量的存储周期是函数的调用时间。

### scanf 函数
在遇到空格、制表符和换行符时会停止读取后面的字符，所以在输入整句英文时只会读取第一个单词后停止

### strlen获取存储字节长度
sizeof 是一个运算符，它可以计算任何类型的数据所占用的内存字节数。
strlen 是一个函数，它只能计算以空字符 '\0' 结尾的字符串中字符的个数，不包括空字符
#### 练习
[day9.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day9.c)

### \#define:定义常量和宏(预处理替换)
#### 定义常量
```C
# define WIFE "散兵"
```
#### 练习
[day10.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day10.c)
#### 定义宏
```C
# define ADD (a,d) a+b
//    宏名 宏的参数 宏体
```
#### 练习
[day11.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day11.c)

### 结构体
#### 基本结构
```C
声明类型 结构体名称（模板）{
    
}
声明类型 结构体名称（模板） 实例;
```

实例是对象的实体化
#### 访问结构的成员

成员访问运算符（`.`）
结构体.结构体成员

#### 练习
[day13.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day13.c)

### 枚举类型
- 枚举类型是一种特殊的类型，它用于定义一组命名的常量整数。

### 派生类型

## 语句
### 分支语句
#### if
##### 基本结构
```C
if (条件表达式) {
    语句1;
} 
else if (条件表达式) {
    语句2;
}
else {
    语句3;
}
```
##### 练习
[day7.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day7.c)

### switch
#### 基本结构
```C
switch (整型表达式) {
    case 整型数值1: 
        语句1;
        break;
    ...
    case 整型数值n: 
        语句n;
        break;
    default:
        语句n+1;
}
```
**switch的条件表达式只能是整型或字符型，不能是其他类型。**
没有break语句的switch语句，执行完第一个匹配的case后，会继续执行后续的case，直到遇到break语句或整个switch语句结束为止
#### 练习
[day12.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day12.c)

### 循环语句
#### while循环
##### 基本结构
```C
while (条件表达式) {
    语句;
}
```
#### 练习
[day6.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day6.c)

#### for循环
##### 基本结构
```C
for(初始化语句;循环条件;自增或自减){
    循环体
}
```
##### 练习
[day14.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day14.c)

#### do while循环
##### 基本结构
```C
do{
    循环体；
}
while(条件表达式);
```
##### 练习
[day15.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day15.c)

### 控制语句
用于控制程序的执行流程
#### break语句
终止当前循环，执行下一条语句。
可用于终止`switch`语句中的一个`case`
#### goto语句
无条件跳转语句
##### 基本结构
```C
标签名:
语句;
goto 标签名;
```
[day17.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day17.c)
#### continue语句
跳过循环体中剩余的语句而强制进入下一次循环
`continue`语句只用在`while`、`for`循环中，常与`if`条件语句一起使用，判断条件是否成立
#### return语句
将函数的返回值传递给调用者，也可以当做结束标志
##### 基本结构
 ```c
    return 表达式;
    或者
    return (表达式);
```

## 指针
指针的类型为：类型*
### 指针类型
指针类型的大小都是4个字节，但是不同类型可以访问的字节随类型变化
#### 传值调用：不加*
将实参的值传递给形参，形参的值改变不会影响实参的值
#### 传址调用：加*
将实参的地址传递给形参，形参的值改变会影响实参的值
### 野指针
指针指向的地址不明确（没有初始化），不存在或者非法访问，称为野指针

# 函数
### 链式访问
一个函数的访问值作为另一个函数的实参
### 函数的声明
用于声明函数的存在
##### 基本结构
```C
类型 函数名(参数表);
```

### 函数的定义
##### 基本结构
```C
类型 函数名(参数表){
    函数体
}
```

### 函数的调用
##### 基本结构
```C
函数名(实参表);
```
**函数可以嵌套使用，但不能嵌套定义**
## 函数的递归（套娃）
在一个函数里调用了另一个函数，且遵循栈后进先出的顺序。先递后归，为递归设置好停止条件和参数，防止程序陷入死循环

在公司里会将函数的声明和实现分别放在.h和.C文件中,再将.C文件编译成静态库lib文件供使用
编译方法：使用 gcc 命令编译. C 文件为. Lib 文件，输入：gcc -c * . C，再输入：ar -cr * . Lib * .O

**EOF（End Of File）是表示文件结束的标志符号**

![4e9703d56f3189ae3c283f5b433be07.jpg](https://s1.vika.cn/space/2024/03/02/a1c38a89ca2b483091d070daccce6411)

## "%c"和"%s"区别
"%c"和"%s"是C语言中的两种格式说明符，用来输出或输入字符和字符串。它们的区别如下：
- **"%c"对应的是单个字符，"%s"对应的是字符串**。例如，char a; char b [20]; scanf ("%c",&a); //只能输入一个字符。 scanf ("%s",b); //可以输入一串不超过20字符的字符串。
- "%c"对应的类型是char，"%s"对应的类型是char *，即字符指针。用作输入时，二者的参数都要传char * 型。"%c"输入函数只会对一个字节空间赋值，而"%s"会一直赋值，直到输入中遇到空白字符为止。用作输出时，"%c"传char类型，输出一个字符，"%s"传char *类型，输出到'\0'为止。
- 输入的时候，scanf ("%c", &a);这里的&不能少，而scanf ("%s",s);这里不能有&符号，因为s本身就是一个指针，指向字符串的首地址。

## 三种输入函数的区别
| 函数 | 格式 | 读取方式 | 数据类型 | 对空格和换行的处理 | 对缓冲区的处理 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| `scanf()` | 格式输入函数 | 读取数字时会跳过空格、制表符和换行符 | 可以输入多种类型的数据 | 输入字符时会忽略空格和换行符 | 从输入流缓冲区中读取值 |
| `fgets()` | 无格式输入函数 | 可以接受空格和换行符 | 可以输入字符串 | 会将空格和换行符当作普通字符处理 | 从输入流缓冲区中读取值 |
| `getchar()` | 键盘输入函数 | 只能输入字符型 | 只能输入单个字符 | 会将空格和换行符当作普通字符处理 | 从输入流缓冲区中读取值 |

# 数组
数组是相同类型数据的有序集合。数组中的每个数据被称为数组元素，可以通过索引来访问数组中的元素。

可以用`[]`下标访问操作符访问元素的下标，下标索引从0开始，最大不超过数组的长度-1

## 二维数组
[day25.c](E:\OneDrive\apply\remotely-save\note\learn\Learn-Python\C\day25.c)
### 变长数组
在 C 99 引入的概念，在支持 C 99 的编译器，比如 gcc 等，可以在程序运行时引入数组的长度，从而动态分配，而不是在编译之前写死不动，但同时数组长度过大会引起栈溢出。
```C
#include <stdio.h>

int main() {
    int size;
    printf("Enter the size of the array: ");
    scanf("%d", &size);

    int array[size]; // 声明一个变长数组

    // 初始化数组
    for (int i = 0; i < size; i++) {
        array[i] = i;
    }

    // 打印数组
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    return 0;
}

```

system("cls")系统清屏命令


**`%2.2f`是`printf`函数的格式化占位符**
- `%` 表示开始一个格式化占位符。
- `2` 表示打印的数字至少占用的宽度。如果数字的长度小于这个宽度，它将用空格填充。
- `.2` 表示小数点后的数字位数，这里是两位。
- `f` 表示浮点数。

# 进阶知识