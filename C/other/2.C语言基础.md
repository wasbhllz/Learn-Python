---
tags:
  - C语言
  - 笔记
---

# 基础知识
## 自定义函数
声明 (确定返回值, 参数) → 调用 (执行函数功能) → 定义 (编写函数定义)
`void a(void)` 中前面的 `void` 表示没有返回值，后面 `void` 表示没有参数, 可以省略不写

变量分为**全局变量**和**局部变量**

## 常量
- 字面常量
- `const` 修饰的常变量，常用于固定不能修改的常量值
- `#define` 定义的符号变量 (一般用大写表示)
**const 和 #define之间的区别在于 ，前者使用内存进行存储，而后者不使用，直接在预处理器替换完成。**

## 数据类型
### 基本数据类型
#### 字符类型
- **`char`**：字符类型，用于储存单个字符，占用的存储空间为 1 个字节。
#### 整型类型
- **`short`**：短整型，占用的存储空间为 2 个字节，用于存储较小的整数。
- **`int`**:整型，占用的存储空间为 4 个字节
- **`long`**：长整型，在32位系统上通常是4个字节，在64位系统上可能是8个字节，用于存储较大的整数。
- **`long long`**：更长的整型，用于存储非常大的整数。
#### 浮点类型
- **`float`**：单精度浮点数，占用的存储空间为 4 个字节，8 位用于表示指数的值和符号，剩下 24 位用于表示非指数部分（也叫作尾数或有效数）及其符号。
- **`double`**：双精度浮点数，占用的存储空间为 8 个字节。11 位用于表示指数的值和符号，剩下 52 位用于表示尾数部分及其符号。
#### 符号类型
- **`unsigned`**：无符号类型，可以是 `unsigned int`, `unsigned char`, `unsigned short`, `unsigned long` 或 `unsigned long long`，用于存储只有非负数的整数。
- **`signed`**：有符号类型，通常与 `char` 一起使用，如 `signed char`，表示可以存储正数和负数的字符类型。
#### 布尔类型
- **`_Bool`**：布尔类型，在C99标准中引入，用于存储 `true` 或 `false`。

### 复合数据类型
- 数组
- 结构体
- 枚举
- 指针

### 空类型
`void`

### 数据类型转换
- 隐式转换
- 显式转换

### 不同进制表示
整数可以表示为十进制、八进制、十六进制或二进制
- 0 前缀表示八进制数
- X 或 X 前缀表示十六进制数
- 0b 或 0B 前缀表示二进制数
- l 或 L 前缀表明该值是 long 类型
- ll 或 LL 前缀表明该值是 longlong 类型

单引号用来表示**字符常量**，双引号用来表示**字符串常量**。

### 字符串
**null 字符: `\0` 是字符串的结束标志**
- `{}`中数组的长度超过`arr[]`声明中的数值时, 会报错
- `arr[]`声明中的数值超过`{}`中数组的长度的时, 会**自动生成 0 填补空位**
- 计算字符数组的长度, 由于字符没有 `\0`,会计算之后储存空间的长度, 直到 `\0`
#### 例题
```C
#include <stdio.h>
int main()
char arr[] = {'b','i','t'};
printf("%d\n"，strlen(arr));
return 0;
```
题目内容:
A.3
B.4
c.随机值
D.5

数组不完全初始化带来的默认初始化

```ad-tldr
title:VS中的小数默认是double类型，需要在小数后面加上`f`表示float类型，如：3.14f
```

## 转义序列
- 字面常量
- `\ddd` 表示一个八进制数, 数字从 0~7，满八进一
- `\xdd` 表示一个十六进制数

## 操作符
### 1. 算术操作符
- 整数运算：运算符的两方都是整数
- 浮点运算：运算符的一方至少有一个浮点数
- `%` 取模运算是取余数, 结果是整数

**'%'操作符不能使用浮点数**
![image-2.png](https://s1.vika.cn/space/2024/01/13/080cac20845941a09e5f451f1c0393af)

### 2. 移位操作符
```ad-tldr
title:**移位和按位中的'位'是指二进制位**
```
**左移**（<<）将一个运算对象的二进制数值（补码）向左移动指定位数（正整数），通过丢弃高位字节并用低位字节（0）填充，从而为运算对象创造一个左移位
正数的原码、反码、补码都相同，而负数的原码、反码、补码需要计算得出
相当于乘以\(2^n\)
```
十进制数：
-7
原码：
10000000000000000000000000000111
反码：取反除最高位外的原码
11111111111111111111111111111000
补码：在反码的基础上加1
11111111111111111111111111111001
```

**右移**（>>）将一个运算对象的二进制数值（补码）向右移动指定位数，通过丢弃高位字节并用低位字节（0）填充，分为算术右移和逻辑右移
算术右移：和符号相同的填充
逻辑右移：高位填 0
相当于除以\(2^n\)
```ad-tldr
title:一般机器和解释器一般进行的是算术右移
```

### 3. 位操作符
按位操作符用于对整数类型的数据的二进制位进行操作
- **按位与** (`&`): 按位与,比较二进制补码中，如果两个都为1为1，都不为1为0
- **按位或** (`|`): 按位或，如果两个有一个为1为1，都不为1为0
- **按位异或** (`^`): 按位异或,同0异1。当两个相同的数进行异或运算时，结果为0。当一个数与0进行异或运算时，结果为它本身。
- **按位取反** (`~`): 按位取反，将1变为0，将0变为1

### 4. 单目操作符
- `sizeof(变量)` 返回操作数的类型长度 (以字节为单位)
- `&` 取地址符
- `*` 间接访问操作符 (解引用操作符)，对指针中的值进行操作
- `++` 自增操作符，前置、后置++
- `--` 自减操作符，前置、后置--
- `(类型)` 强制类型转换

```
++i 前置，先增加，后使用
i++ 后置，先使用（复制、打印或返回），后增加
```

### 5. 关系操作符
`>`
`>=`
`<`
`<=`
`!=`
`==`
- 关系操作符的结果是布尔值
- 关系操作符的优先级低于算术操作符
- 关系操作符的优先级高于赋值操作符

### 6. 逻辑操作符
- `&&` 逻辑与：左边为假，右边就不计算了
- `||` 逻辑或：左边为真，右边就不计算了
- `!` 逻辑非

### 7. 条件操作符
**三目操作符**
```
表达式1 ? 表达式2: 表达式3
```
表达式 1 为真，返回表达式 2 的值，否则返回表达式 3 的值

### 8. 逗号表达式
```
表达式1,表达式2,表达式3,...
```
以最后的表达式为结果

### 下标引用、函数调用和结构体访问操作符
- `[索引数]` 下标引用，跟数组的指针一起用
- `()` 函数调用
**`.` 结构成员引用**

可以使用点操作符来访问其成员，例如，如果 `student` 是一个 `Student` 结构体的实例，你可以使用 `student.name` 来访问其 `name` 成员
**`->` 结构成员访问**

例如，如果 `pStudent` 是指向 `Student` 结构体的指针，你可以使用 `pStudent->name` 来访问其 `name` 成员。

### 7. 运算符优先级
运算符的优先级和结合性
#### 整形提升
- 当**小于 int 类型**的类型进行计算时，如果是有符号类型，会将补码按最高位的符号位进行填充，否则按 0填充
- **高于 int 类型**的会按计算中最高类型向上取整
#### 表达式的运算
虽然运算符的顺序是已经规范定义的，但在实际编程中，我们还是需要注意以下情况：
当进行**相同变量的多次运算**时，确实可能存在未定义行为，特别是在并行计算或优化编译的情况下

### Bool 类型
用于表示布尔值，即逻辑值 `true` 和 `false`。因为 C 语言用值 1 表示 `true`，值 0 表示 `false`，所以 `Bool` 类型实际上也是一种整数类型

## 关键字
### Typedef 类型重命名 
用途：类型定义太长太复杂的时候进行重命名 

### Static
**静态局部变量**: 修饰局部变量出了作用域是不销毁的
栈区：局部变量—>静态变量（静态区）
**静态全局变量**:修饰全局变量的外部链接属性变成了内部属性 (作用域变小了, 原本的范围是整个项目)
**静态函数**：效果和静态全局变量类似
- 限制变量和函数的作用域，使其只能在本文件或本函数内访问，隐藏其它文件或函数的同名变量和函数。
- 保持变量的内容的持久，使其在程序运行期间一直存在，不受函数调用的影响。
- 默认初始化变量为 0，省去了手动赋值的操作。

### Register：寄存器变量
- 只能作用于局部变量，不能作用于全局变量。
- 只是向编译器提出请求，但不一定请求成功。编译器会根据寄存器的数量和类型来决定是否将变量放入寄存器中。
- Register 变量必须是能被 CPU 寄存器所接受的类型，通常意味着 register 变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。有些机器的寄存器也能存放浮点数。
- 不能用&运算符获取 register 变量的地址，因为寄存器变量可能不存放在内存中，而寄存器不能通过地址直接访问。
- 不能与 static 关键字一起使用，因为 static 关键字表示变量的存储周期是整个程序的运行时间，而 register 关键字表示变量的存储周期是函数的调用时间。

### Scanf 函数
在遇到空格、制表符和换行符时会停止读取后面的字符，所以在输入整句英文时只会读取第一个单词后停止

### Strlen 获取存储字节长度
Sizeof 是一个运算符，它可以计算任何类型的数据所占用的内存字节数。
Strlen 是一个函数，它只能计算以空字符 '\0' 结尾的字符串中字符的个数，不包括空字符

### \ #define :定义常量和宏 (预处理替换)
#### 定义常量
```C
# define WIFE "散兵"
```
#### 练习
[day10.c](E:\OneDrive\apply\remotely-save\note\Learn-Python\C\day10.c)
#### 定义宏
```C
# define ADD (a,d) a+b
//    宏名 宏的参数 宏体
```

### 结构体
#### 基本结构
```C
声明类型 结构体名称（模板）{
    
}
声明类型 结构体名称（模板） 实例;
```
#### 结构体初始化
实例是对象的实体化
#### 结构体成员访问

成员访问运算符（`.`）
结构体. 结构体成员
#### 结构体传参
结构体作为参数传递时，传递的是结构体变量的地址，一般情况下建议传址调用

### 枚举类型
- 枚举类型是一种特殊的类型，它用于定义一组命名的常量整数。

### 派生类型

## 语句
### 分支语句
#### if 语句
##### 基本结构
```C
if (条件表达式) {
    语句1;
} 
else if (条件表达式) {
    语句2;
}
else {
    语句3;
}
```

### Switch
#### 基本结构
```C
switch (整型表达式) {
    case 整型数值1: 
        语句1;
        break;
    ...
    case 整型数值n: 
        语句n;
        break;
    default:
        语句n+1;
}
```
**switch 的条件表达式只能是整型或字符型，不能是其他类型。**
没有 break 语句的 switch 语句，执行完第一个匹配的 case 后，会继续执行后续的 case，直到遇到 break 语句或整个 switch 语句结束为止

### 循环语句
#### While 循环
##### 基本结构
```C
while (条件表达式) {
    语句;
}
```

#### For 循环
##### 基本结构
```C
for(初始化语句;循环条件;自增或自减){
    循环体
}
```

#### Do while 循环
##### 基本结构
```C
do{
    循环体；
}
while(条件表达式);
```
##### 练习

### 控制语句
用于控制程序的执行流程
#### Break 语句
终止当前循环，执行下一条语句。
可用于终止 `switch` 语句中的一个 `case`
#### Goto 语句
无条件跳转语句
##### 基本结构
```C
标签名:
语句;
goto 标签名;
```

#### Continue 语句
跳过循环体中剩余的语句而强制进入下一次循环
`continue` 语句只用在 `while`、`for` 循环中，常与 `if` 条件语句一起使用，判断条件是否成立
#### Return 语句
将函数的返回值传递给调用者，也可以当做结束标志
##### 基本结构
 ```c
    return 表达式;
    或者
    return (表达式);
```

## 指针
### 指针的定义
指针是指指针变量，是存放地址的变量
```C
    int a = 10;
    int* p = &a;
```
指针的类型为：类型*
### 指针类型
**指针的大小取决于平台，在 32 位平台上都是 4 个字节，在 64 位平台上都是 8 个字节**
指针类型的大小都是 4 个字节，但是不同类型可以访问的字节随类型变化

### 野指针
指针指向的内存空间**没有初始化（NULL）**，或者已经释放
### 指针的运算
#### 指针的加减
指针变量可以进行加减法运算
### 指针数组
指针数组是指存放指针的数组

**指针数组的声明关注的是指针的数量（列数），而指针指向的具体数据结构（行数）则取决于程序的其他部分如何使用和赋值这些指针**

#### 传值调用：不加*
将实参的值传递给形参，形参的值改变不会影响实参的值
#### 传址调用：加*
将实参的地址传递给形参，形参的值改变会影响实参的值
### 野指针
指针指向的地址不明确（没有初始化），不存在或者非法访问，称为野指针

1. **未初始化的指针**：如果声明了一个指针变量但没有给它赋予一个确切的、有效的地址，那么它就是一个野指针。
2. **已释放的内存空间**：如果指针指向的内存被释放（如通过 `free` 或 `delete`），但指针没有被设置为 `NULL`，它仍然指向那个地址，这时它就成了野指针。
3. **超出作用域的指针**：如果指针指向一个局部变量的地址，而该局部变量的作用域已经结束，那么该指针也会成为野指针。
4. **指针运算错误**：错误的指针运算可能导致指针指向一个随机的内存地址，从而成为野指针。

 ```ad-tldr
title:为了避免出现这种情况，应该将指针初始化设置为 `NULL`，以及**避免返回指向局部变量的指针**
```

```
### 指针的运算
```C
// 指针的地址增加
*ps++;
// 指针所指向的值增加
(*ps)++;
```

# 函数
### 链式访问
一个函数的访问值作为另一个函数的实参
### 函数的声明
用于声明函数的存在
##### 基本结构
```C
类型 函数名(参数表);
```

### 函数的定义
##### 基本结构
```C
类型 函数名(参数表){
    函数体
}
```

### 函数的调用
##### 基本结构
```C
函数名(实参表);
```
**函数可以嵌套使用，但不能嵌套定义**
## 函数的递归（套娃）
在一个函数里调用了另一个函数，且遵循栈后进先出的顺序。先递后归，为递归设置好停止条件和参数，防止程序陷入死循环

在公司里会将函数的声明和实现分别放在. H 和. C 文件中, 再将. C 文件编译成静态库 lib 文件供使用
编译方法：使用 gcc 命令编译. C 文件为. Lib 文件，输入：gcc -c * . C，再输入：ar -cr * . Lib * .O

**EOF（End Of File）是表示文件结束的标志符号**

![4e9703d56f3189ae3c283f5b433be07.jpg](https://s1.vika.cn/space/2024/03/02/a1c38a89ca2b483091d070daccce6411)

## "%c"和"%s"区别
"%c"和"%s"是 C 语言中的两种格式说明符，用来输出或输入字符和字符串。它们的区别如下：
- **"%c"对应的是单个字符，"%s"对应的是字符串**。例如，char a; char b [20]; scanf ("%c",&a); //只能输入一个字符。 Scanf ("%s", b); //可以输入一串不超过 20 字符的字符串。
- "%c"对应的类型是 char，"%s"对应的类型是 char \*，即字符指针。用作输入时，二者的参数都要传 char * 型。"%c"输入函数只会对一个字节空间赋值，而"%s"会一直赋值，直到输入中遇到空白字符为止。用作输出时，"%c"传 char 类型，输出一个字符，"%s"传 char *类型，输出到'\0'为止。
- 输入的时候，scanf ("%c", &a); 这里的&不能少，而 scanf ("%s", s); 这里不能有&符号，因为 s 本身就是一个指针，指向字符串的首地址。

## 三种输入函数的区别
| 函数 | 格式 | 读取方式 | 数据类型 | 对空格和换行的处理 | 对缓冲区的处理 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| `scanf()` | 格式输入函数 | 读取数字时会跳过空格、制表符和换行符 | 可以输入多种类型的数据 | 输入字符时会忽略空格和换行符 | 从输入流缓冲区中读取值 |
| `fgets()` | 无格式输入函数 | 可以接受空格和换行符 | 可以输入字符串 | 会将空格和换行符当作普通字符处理 | 从输入流缓冲区中读取值 |
| `getchar()` | 键盘输入函数 | 只能输入字符型 | 只能输入单个字符 | 会将空格和换行符当作普通字符处理 | 从输入流缓冲区中读取值 |

# 数组
数组是相同类型数据的有序集合。数组中的每个数据被称为数组元素，可以通过索引来访问数组中的元素。
## 访问数组元素
可以用 `[]` 下标访问操作符访问元素的下标，下标索引从 0 开始，最大不超过数组的长度-1

## 二维数组

### 变长数组
在 C 99 引入的概念，在支持 C 99 的编译器，比如 gcc 等，可以在程序运行时引入数组的长度，从而动态分配，而不是在编译之前写死不动，但同时数组长度过大会引起栈溢出。
```C
#include <stdio.h>

int main() {
    int size;
    printf("Enter the size of the array: ");
    scanf("%d", &size);

    int array[size]; // 声明一个变长数组

    // 初始化数组
    for (int i = 0; i < size; i++) {
        array[i] = i;
    }

    // 打印数组
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    return 0;
}
```

System ("cls")系统清屏命令


**`%2.2f` 是 `printf` 函数的格式化占位符**
- `%` 表示开始一个格式化占位符。
- `2` 表示打印的数字至少占用的宽度。如果数字的长度小于这个宽度，它将用空格填充。
- `.2` 表示小数点后的数字位数，这里是两位。
- `f` 表示浮点数。
