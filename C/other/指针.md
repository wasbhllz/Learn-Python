# C语言基础：指针

## 引言
在C语言中，指针是一种强大的工具，它允许程序直接访问内存。通过指针，我们可以操作变量的地址，从而更加灵活地控制数据。

## 基础概念
### 指针基础
#### **指针**
- 指针是一个变量，其值为另一个变量的地址，即直接指向内存中的一个位置。
```c
int var = 20;      // 实际变量声明
int *ip;           // 指针变量声明
ip = &var;         // 在指针变量中存储 var 的地址
```

#### **野指针**
- 野指针是指向不确定内存区域的指针。使用未初始化或已释放的内存的指针可能导致程序崩溃或不可预测的行为。
```c
int *ptr; // 未初始化的指针
*ptr = 5; // 危险操作，ptr 可能指向任意位置
```

#### **二级指针**
- 二级指针是指向指针的指针，它可以存储另一个指针变量的地址。
```c
int var = 3000;
int *ptr = &var;
int **pptr = &ptr;
```
### 基础知识
#### **指针类型**
- 指针类型必须与它指向的变量类型相匹配。这决定了指针运算和间接引用的行为。
```c
int *ip;    // 指向整型
char *cp;   // 指向字符型
```
#### **指针解引用**
访问内存，对指针中的值进行操作
#### **指针的运算**
- 指针可以进行算术运算，如增加或减少其指向的地址。
```c
int v[3] = {10, 100, 200};
int *ptr = v;
for (int i = 0; i < 3; i++) {
  printf("Address of v[%d] = %p\n", i, ptr);
  printf("Value of v[%d] = %d\n", i, *ptr);
  ptr++;
}
```
![1713102382633.jpg](https://s1.vika.cn/space/2024/05/13/e5a17c92ac604a3ebb5d800f4bc4c41e)



## 基础难点
- **理解指针与地址的关系**：指针变量存储的是地址，而不是值。
- **指针的正确初始化**：未初始化的指针可能导致程序错误。
- **指针的范围和边界**：指针越界可能会导致数据损坏。

## 进阶学习
### 进阶知识
#### **指针与函数**
使用指针作为函数参数可以修改外部变量。
#### **指针数组与数组指针**
理解这两者的区别对于高级编程至关重要。

### 高级运用
- **动态内存分配**：使用指针和 `malloc` 或 `calloc` 函数动态分配内存。
- **使用指针进行数组排序、查找等操作**：通过指针可以高效地对数组进行操作，如快速排序、二分查找等。

## 注意事项
- **避免野指针**：总是初始化指针。
- **小心指针运算**：确保指针运算不会导致越界。

### 学习难点
- **指针与多维数组**：多维数组的指针运算可能很复杂。
- **指针类型转换**：不同类型的指针之间的转换需要谨慎处理。

## 总结
指针是C语言中一个非常强大的特性，它允许程序员直接操作内存。理解和正确使用指针是成为一名高效C程序员的关键。通过本篇笔记，我们回顾了指针的基础知识，探讨了使用指针时的注意事项和常见难点，为深入学习打下了坚实的基础。接下来，我们可以继续探索指针在数据结构和算法中的应用，以及它们在系统编程中的重要性。
















### 指针的定义
指针是指指针变量，是存放地址的变量
```C
    int a = 10;
    int* p = &a;
```
指针的类型为：类型*
### 指针类型
**指针的大小取决于平台，在 32 位平台上都是 4 个字节，在 64 位平台上都是 8 个字节**
指针类型的大小都是 4 个字节，但是不同类型可以访问的字节随类型变化
![1713102383093.jpg](https://s1.vika.cn/space/2024/04/15/ae51ed2a0ae54c99b94346a0e5117809)

### 野指针
指针指向的地址不明确（没有初始化），不存在或者非法访问，称为野指针

1. **未初始化的指针**：如果声明了一个指针变量但没有给它赋予一个确切的、有效的地址，那么它就是一个野指针。
2. **已释放的内存空间**：如果指针指向的内存被释放（如通过 `free` 或 `delete`），但指针没有被设置为 `NULL`，它仍然指向那个地址，这时它就成了野指针。
3. **超出作用域的指针**：如果指针指向一个局部变量的地址，而该局部变量的作用域已经结束，那么该指针也会成为野指针。
4. **指针运算错误**：错误的指针运算可能导致指针指向一个随机的内存地址，从而成为野指针。

### 二级指针
存放一级指针地址的指针
```C
    int a = 10;
    int* p = &a;
    int** pp = &p; //二级指针
```
### 指针的运算
#### 指针的加减
指针变量可以进行加减法运算
### 指针数组
指针数组是指存放指针的数组

### 指针和数组

**指针数组的声明关注的是指针的数量（列数），而指针指向的具体数据结构（行数）则取决于程序的其他部分如何使用和赋值这些指针**

#### 传值调用：不加*
将实参的值传递给形参，形参的值改变不会影响实参的值
#### 传址调用：加*
将实参的地址传递给形参，形参的值改变会影响实参的值
![1713102383103.jpg](https://s1.vika.cn/space/2024/04/15/db4c5452009f428bb1ea7c3bd1742f7a)

 ```ad-tldr
title:为了避免出现这种情况，应该将指针初始化设置为 `NULL`，以及**避免返回指向局部变量的指针**
```

```
### 指针的运算
```C
// 指针的地址增加
*ps++;
// 指针所指向的值增加
(*ps)++;
```





## **指针的基础概念**
### **指针算术**
- 解释指针的算术操作，包括指针的增减、指针间的减法、指针与整数的加法，以及指针的比较。

```c
int arr[10];
int *ptr = arr;
ptr += 2; // ptr现在指向arr[2]
```
### **void指针**
- 介绍void指针，它是一种通用指针类型，可以指向任何类型的数据。void指针常用于库函数的参数，以接受任何类型的指针。
```c
void *voidPtr;
int *intPtr;
voidPtr = intPtr; // void指针可以存储任何类型的指针
```
### **指针与const**
- 讨论const与指针的结合使用，包括const指针、指向const的指针和const指针的const。
```c
int var = 5;
const int *ptr1 = &var; // 指向const的指针，不能通过ptr1修改var
int *const ptr2 = &var; // const指针，ptr2的地址不能更改，但可以修改var
const int *const ptr3 = &var; // const指针的const，既不能修改地址也不能修改值
```
## **指针和函数**
### **指针与函数参数**
- 讨论如何通过指针将变量的地址传递给函数，从而允许函数直接修改外部变量的值。
```c
void modifyValue(int *ptr) {
    *ptr = 10; // 直接修改指针指向的值
}
int main() {
    int value = 5;
    modifyValue(&value); // 传递value的地址
    // value现在被修改为10
}
```
### **函数指针**
- 介绍如何使用函数指针，包括函数指针的定义、赋值和调用。
```c
void (*funcPtr)(int) = &function; // 函数指针赋值
funcPtr(42); // 通过函数指针调用函数
```
## **指针类型的高级应用**
### **指针数组和数组指针的区别**
- 解释指针数组和数组指针的概念，并强调它们的区别。
```c
int *ptrArray[10]; // 指针数组：数组元素是指针
int (*arrayPtr)[10]; // 数组指针：指向数组的指针
```
### **指向多维数组的指针**
- 解释如何使用指针访问多维数组的元素，包括行指针和列指针的概念。
```c
int matrix[3][4];
int (*rowPtr)[4] = matrix; // 行指针
int *colPtr = *matrix; // 列指针
```

## **指针与数据结构**
### **指针与结构体**
- 解释如何使用指针访问结构体的成员，以及如何通过指针传递和返回结构体。
```c
struct Example {
    int value;
};
struct Example ex;
struct Example *ptr = &ex;
ptr->value = 10; // 通过指针访问结构体成员
```
## **指针的安全**
### **指针的安全性**
- 强调指针操作的安全性，包括避免悬空指针、内存泄漏和越界访问等问题。
```c
int *ptr = malloc(sizeof(int) * 10);
// ... 使用ptr ...
free(ptr); // 使用完毕后释放内存
ptr = NULL; // 避免悬空指针
```
